#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/UefiApplicationEntryPoint.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/RngLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Protocol/SimpleFileSystem.h>
#include <Protocol/LoadedImage.h>

// Configuración del Tablero
#define MAP_WIDTH  60  // Un poco más ancho para que se vea bien en consola
#define MAP_HEIGHT 125

// Entidades del Juego
#define CHAR_WALL   L'#' 
#define CHAR_EMPTY  L' ' 
#define CHAR_PLAYER L'@' 
#define CHAR_ENEMY  L'X' 
#define CHAR_GOAL   L'P'

// Colores (Usando los defines estándar de UEFI)
#define COLOR_WALL   EFI_LIGHTGRAY
#define COLOR_EMPTY  EFI_BLACK
#define COLOR_PLAYER EFI_MAGENTA
#define COLOR_ENEMY  EFI_LIGHT_RED // El color del pánico
#define COLOR_GOAL   EFI_YELLOW

#define DIR_RIGHT 0
#define DIR_LEFT  1

typedef struct {
    INTN x;
    INTN y;
} POINT;

// Matriz Global del Mapa
CHAR16 GameMap[MAP_HEIGHT][MAP_WIDTH];



UINT16 GetRandom(UINT16 Max) {
    UINT16 Rand;
    GetRandomNumber16(&Rand);
    return Rand % Max;
}


// Función auxiliar para "excavar" un área de 3x3 alrededor de un punto
void CarveBrush(INTN center_x, INTN center_y) {
    for (INTN y = center_y - 3; y <= center_y + 3; y++) {
        for (INTN x = center_x - 3; x <= center_x + 3; x++) {
            // Verificar límites seguros (dejando bordes intocables)
            if (x > 0 && x < MAP_WIDTH - 1 && y > 0 && y < MAP_HEIGHT - 1) {
                GameMap[y][x] = CHAR_EMPTY;
            }
        }
    }
}

void InitMap() {
    UINT16 Rnd;
    INTN x, y;
    
    // 1. Empezamos con el mapa SOLIDO (todo pared)
    for (y = 0; y < MAP_HEIGHT; y++) {
        for (x = 0; x < MAP_WIDTH; x++) {
            GameMap[y][x] = CHAR_WALL;
        }
    }

    // 2. Definir Inicio y Fin (Esquinas opuestas)
    INTN CurrentX = 2;
    INTN CurrentY = 0;

    INTN TargetsX[10];
    INTN TargetX;
    INTN TargetY;
    
    // Asegurar que inicio y fin estén limpios
    GameMap[CurrentY][CurrentX] = CHAR_EMPTY;
        
    
    INTN stepX = MAP_WIDTH / 10;
    INTN stepY = MAP_HEIGHT / 10;
    
    for (INTN i = 0; i < 10; i++) {
        TargetsX[i] = GetRandom(stepX) + i * stepX;
    }
    // Extra Randomness
    while(GetRandom(2) == 0) {
        INTN foo = GetRandom(10);
        INTN bar = GetRandom(10);

        TargetsX[foo] ^= TargetsX[bar];
        TargetsX[bar] ^= TargetsX[foo];
        TargetsX[foo] ^= TargetsX[bar];
    }


    // Excavador Borracho
    for (INTN i = 0; i < 10; i++) {
        TargetX = TargetsX[i];
        TargetY = ((i+1) * stepY) - 1;

        while (CurrentX != TargetX || CurrentY != TargetY) {
            // Excavamos donde estamos parados (Radio 3x3)
            CarveBrush(CurrentX, CurrentY);

            // Decidir el siguiente paso
            GetRandomNumber16(&Rnd);
            UINTN Direction = Rnd % 100; // 0-99

            INTN NextX = CurrentX;
            INTN NextY = CurrentY;

            if (Direction < 100) { // Movimiento Inteligente: Acercarse al objetivo
                if (CurrentX < TargetX) NextX++;
                else if (CurrentX > TargetX) NextX--;

                if (CurrentY < TargetY) NextY++;
            } else { // Movimiento Borracho: Tambalearse un poco
                INTN step = GetRandom(3) - 1; // -1, 0, +1
                NextX += step;

            }

            // Validar límites del mapa
            if (NextX > 0 && NextX < MAP_WIDTH - 1) CurrentX = NextX;
            if (NextY > 0 && NextY < MAP_HEIGHT - 1) CurrentY = NextY;
        }

        // Asegurar limpieza final en la meta
        CarveBrush(TargetX, TargetY);
    }
}


UINTN LastAttribute = 0;

// Helper para dibujar un solo caracter en una posición con color
void DrawTile(INTN x, INTN y, CHAR16 Char, UINTN Attribute) {
    if (LastAttribute != Attribute) {
        gST->ConOut->SetAttribute(gST->ConOut, Attribute);
        LastAttribute = Attribute;
    }

    gST->ConOut->SetAttribute(gST->ConOut, Attribute);
    gST->ConOut->SetCursorPosition(gST->ConOut, x, y);
    
    // Truco sucio para imprimir un solo CHAR16: crear un string de 2 chars
    CHAR16 Buffer[2];
    Buffer[0] = Char;
    Buffer[1] = L'\0';
    gST->ConOut->OutputString(gST->ConOut, Buffer);
}


#define VIEWPORT_HEIGHT 25 // Número de líneas visibles en la pantalla

EFI_STATUS
EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
)
{
    EFI_INPUT_KEY Key = {0};
    INTN PlayerX = MAP_WIDTH / 2; // Posición inicial en X (centro del mapa)
    INTN PlayerY = 5; // Posición inicial en Y (cerca de la parte inferior de la ventana)
    UINTN Direction = DIR_RIGHT; // Dirección inicial en X
    INTN ScrollOffset = 0; // Desplazamiento vertical del mapa (scrolling)

    // Configuración de FPS y scrolling
    const UINTN FrameTime = 100000; // 40 FPS (25 ms por frame)

    // Crear un evento de temporizador
    EFI_EVENT TimerEvent;
    gBS->CreateEvent(EVT_TIMER, TPL_CALLBACK, NULL, NULL, &TimerEvent);
    gBS->SetTimer(TimerEvent, TimerPeriodic, FrameTime); // Configurar temporizador

    // Inicializar el mapa
    InitMap();

    while (TRUE) {
        UINTN Index;
        gBS->WaitForEvent(1, &TimerEvent, &Index);

        while (gST->ConIn->ReadKeyStroke(gST->ConIn, &Key) != EFI_NOT_READY) {
            if (Key.ScanCode == SCAN_LEFT) {
                Direction = DIR_LEFT;
            } else if (Key.ScanCode == SCAN_RIGHT) {
                Direction = DIR_RIGHT;
            }
        }
        
        if (Direction == DIR_RIGHT) {
            if (PlayerX < MAP_WIDTH - 1 ) {
                PlayerX++;
            }
        } else if (Direction == DIR_LEFT) {
            if (PlayerX > 0 ) {
                PlayerX--;
            }
        }
        ScrollOffset++; // Desplazar la ventana hacia arriba
        
        // Renderizar la ventana visible del mapa
        if (ScrollOffset + VIEWPORT_HEIGHT >= MAP_HEIGHT) {
            DrawTile(PlayerX, PlayerY, CHAR_EMPTY, COLOR_EMPTY);
            PlayerY += 1;
            DrawTile(PlayerX, PlayerY, CHAR_PLAYER, COLOR_PLAYER); // Dibujar jugador en nueva posición
            continue;
        }
        for (INTN y = 0; y < VIEWPORT_HEIGHT; y++) {
            for (INTN x = 0; x < MAP_WIDTH; x++) {
                CHAR16 Tile = GameMap[ScrollOffset + y][x];
                
                if (y == PlayerY && x == PlayerX) {
                    DrawTile(x, y, CHAR_PLAYER, COLOR_PLAYER);
                } else {
                    UINTN Attr = (Tile == CHAR_WALL) ? COLOR_WALL : COLOR_EMPTY;
                    DrawTile(x, y, Tile, Attr);
                }
            }
        }

    }
    gBS->CloseEvent(TimerEvent);

    return EFI_ABORTED;
}